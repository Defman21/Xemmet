// Generated by CoffeeScript 2.0.0-beta1
var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

(function() {
  var Cc, Ci, baseLangs, beautify, beautifyConfig, emmet, ignoreExpand, inWrapMode, loaded, log, logLevel, notified, notify, prefs, selection, snippets, subLangs;
  prefs = require('./extra/prefs');
  emmet = require('./sdk/emmet');
  beautify = require('./sdk/beautify/beautify');
  snippets = require('./extra/snippets');
  log = require('ko/logging').getLogger('xemmet');
  logLevel = require('ko/logging').LOG_DEBUG;
  notify = require('notify/notify');
  ({Cc, Ci} = require('chrome'));
  baseLangs = {
    html: ['html', 'html5', 'rhtml', 'erb', 'markdown', 'php'],
    css: ['css', 'scss', 'less', 'sass']
  };
  ignoreExpand = {
    css: [/^\$/]
  };
  beautifyConfig = {
    indent_size: 1,
    indent_char: '\t',
    unformatted: []
  };
  subLangs = {
    html: [],
    css: []
  };
  notified = false;
  loaded = false;
  inWrapMode = false;
  selection = null;
  this.debug = {};
  this.prefs = require('ko/prefs');
  this._loadInjector = () => {
    prefs.injectPref({
      basename: 'pref-editsmart',
      siblingSelector: '#highlightvariable_groupbox',
      caption: 'Xemmet'
    });
    return log.debug('Injected preferences');
  };
  this._upgradeLanguages = () => {
    var customCssLangs, customHtmlLangs;
    customCssLangs = this.prefs.getString('xemmet_css_languages', '').split(" ");
    customHtmlLangs = this.prefs.getString('xemmet_html_languages', '').split(" ");
    subLangs.css = customCssLangs;
    return subLangs.html = customHtmlLangs;
  };
  this._loadSystemSnippets = (data) => {
    var e;
    if (data) {
      try {
        emmet.loadSystemSnippets(data);
        return log.debug('Loaded system snippets');
      } catch (error) {
        e = error;
        return log.error(e);
      }
    }
  };
  this._loadUserSnippets = () => {
    var dirsSvc, e, file, path;
    file = require('ko/file');
    dirsSvc = Cc['@activestate.com/koDirs;1'].getService(Ci.koIDirs);
    path = file.join(dirsSvc.userDataDir, 'snippets.json');
    if (file.exists(path)) {
      try {
        emmet.loadSnippets(JSON.parse(file.read(path)));
        return log.debug('Loaded user snippets');
      } catch (error) {
        e = error;
        if (!notified) {
          notify.send('Xemmet: unable to load your snippets', {
            priority: 'error',
            category: 'xemmet'
          });
          notified = true;
          return log.warn(e);
        }
      }
    }
  };
  this.__debug__ = () => {
    return log.setLevel(require('ko/logging').LOG_DEBUG);
  };
  this.load = () => {
    var e;
    if (!this.prefs.getBoolean('xemmet_enabled', true)) {
      return false;
    }
    try {
      this.prefs.getString('xemmet_css_languages');
      this.prefs.getString('xemmet_html_languages');
    } catch (error) {
      e = error;
      log.debug('First run');
      this.prefs.setString('xemmet_css_languages', baseLangs.css.join(" "));
      this.prefs.setString('xemmet_html_languages', baseLangs.html.join(" "));
    }
    window.addEventListener('keydown', this.onKeyDownListener, true);
    window.addEventListener('editor_view_opened', this.onViewOpened, true);
    log.setLevel(logLevel);
    if (!loaded) {
      loaded = true;
    }
    this._loadInjector();
    require('notify/categories').register('xemmet', {
      label: 'Xemmet'
    });
    this._upgradeLanguages();
    this._loadSystemSnippets(snippets.snippets());
    this._loadUserSnippets();
    return log.debug('Loaded');
  };
  this.unload = () => {
    window.removeEventListener('keydown', this.onKeyDownListener, true);
    window.removeEventListener('editor_view_opened', this.onViewOpened, true);
    loaded = false;
    return log.debug('Unloaded');
  };
  this.enable = () => {
    if (loaded) {
      return false;
    }
    return this.load();
  };
  this.disable = () => {
    if (!loaded) {
      return false;
    }
    return this.unload();
  };
  this._createSnippet = (text, noIndent) => {
    return {
      type: 'snippet',
      name: 'xemmet-temp-snippet',
      parent: {
        name: 'xemmet-parent'
      },
      set_selection: false,
      indent_relative: !noIndent,
      value: text,
      hasAttribute: (name) => {
        return indexOf.call(this, name) >= 0;
      },
      getStringAttribute: (name) => {
        return '' + this[name];
      }
    };
  };
  this._replace = (text, rules) => {
    var i, len1, rule;
    for (i = 0, len1 = rules.length; i < len1; i++) {
      rule = rules[i];
      text = text.replace(rule.regex, rule.replace);
    }
    return text;
  };
  this._prepare = (snippet, replaceWith = null) => {
    var prepared, rules;
    log.debug(`@_prepare: args = ${JSON.stringify(arguments)}`);
    rules = [
      {
        regex: /\|/gmi,
        replace: replaceWith || '[[%tabstop:]]'
      }, {
        regex: /(\$.*?\{[\t\s\n.]*?(\d+|\w+)(?:\:(.+?))?[\t\s\n.]*?\})/gmi,
        replace: (_, g1, g2, g3) => {
          if (replaceWith) {
            return replaceWith;
          }
          if (isNaN(g2)) {
            g3 = g2;
            g2 = "";
          }
          if (typeof g3 === 'undefined') {
            g3 = "";
          }
          return `[[%tabstop${g2}:${g3}]]`;
        }
      }, {
        regex: /\{\s*\}/gmi,
        replace: replaceWith || '{[[%tabstop:]]}'
      }
    ];
    prepared = this._replace(snippet, rules);
    log.debug(`@_prepare return = ${prepared}`);
    return prepared;
  };
  this._getBaseLang = (lang) => {
    if (indexOf.call(subLangs.html, lang) >= 0) {
      return 'html';
    }
    if (indexOf.call(subLangs.css, lang) >= 0) {
      return 'css';
    }
    return lang;
  };
  this._isEnabledLang = (lang) => {
    if (indexOf.call(subLangs.html, lang) >= 0 || indexOf.call(subLangs.css, lang) >= 0) {
      return true;
    }
    return false;
  };
  this._beautify = (data) => {
    var editor;
    editor = require('ko/editor');
    if (!editor.scimoz().useTabs) {
      log.debug('@_beautify indent = spaces');
      beautifyConfig.indent_size = editor.scimoz().indent;
      beautifyConfig.indent_char = " ";
    } else {
      log.debug('@_beautify indent = tabs');
    }
    return beautify.html(data, beautifyConfig);
  };
  this._expand = (string, language, noBeautify = false) => {
    var e, expand;
    log.debug(`@_expand args = ${JSON.stringify(arguments)}`);
    try {
      expand = emmet.expandAbbreviation(string, language);
      log.debug(`@_expand expand = ${expand}`);
      if (noBeautify) {
        log.debug(`@_expand return = ${expand}`);
        return expand;
      }
      if (this._getBaseLang(language) === 'html') {
        expand = this._beautify(expand);
      }
      log.debug(`@_expand return = ${expand}; beautified!`);
      return expand;
    } catch (error) {
      e = error;
      log.debug(`@_expand return = ${expand}; exception!`);
      return expand;
    }
  };
  this._extractAbbr = (string) => {
    return emmet.utils.action.extractAbbreviation(string);
  };
  this._isAbbr = (string) => {
    var e, extract;
    log.debug(`@_isAbbr args = ${JSON.stringify(arguments)}`);
    try {
      extract = this._extractAbbr(string);
      if (extract.trim().length === 0) {
        log.debug('@_isAbbr abbreviation is invalid/empty');
        return {
          success: false
        };
      }
      log.debug(`@_isAbbr extract = ${extract}; success!`);
      return {
        success: true,
        data: extract,
        length: extract.length
      };
    } catch (error) {
      e = error;
      log.error(`@_isAbbr invalid abbreviation = ${extract}`);
      log.exception(e);
      return {
        success: false
      };
    }
  };
  this._strip = (string) => {
    return string.replace(/<(?:.|\n)*?>/gm, '');
  };
  this._finalize = () => {
    log.info('Current string is not a valid Emmet abbreviation, passing it to Komodo handlers');
    return true;
  };
  this._createSelection = (abbrLength, editor) => {
    var end, start;
    [start, end] = [editor.getCursorPosition(), editor.getCursorPosition()];
    start.ch -= abbrLength;
    editor.setSelection(start, end);
    return log.debug('@_createSelection created a selection');
  };
  this._wrapSelection = (editor, language) => {
    var abbreviation, e, expand, snippet, wrapWith;
    wrapWith = editor.getLine().substring(0, editor.getCursorPosition().ch);
    log.debug(`@_wrapSelection wrapWith = ${wrapWith}`);
    wrapWith = this._extractAbbr(this._strip(wrapWith));
    log.debug(`@_wrapSelection @_extractAbbr(wrapWith) = ${wrapWith}`);
    this._createSelection(wrapWith.length, editor);
    abbreviation = this._isAbbr(wrapWith);
    if (abbreviation.success) {
      expand = this._prepare(this._expand(abbreviation.data, language, true), '[[replace]]');
      expand = expand.replace('[[replace]]', selection);
      log.debug(`@_wrapSelection to insert = ${expand}`);
      try {
        expand = this._beautify(expand);
      } catch (error) {
        e = error;
        log.debug('unable to beautify the result');
      }
      snippet = this._createSnippet(expand, false);
      ko.abbrev.insertAbbrevSnippet(snippet, require('ko/views').current().get());
    } else {
      notify.send(`Xemmet: abbreviation ${wrapWith} is invalid`, {
        priority: 'error',
        category: 'xemmet'
      });
      return false;
    }
    return true;
  };
  this.onViewOpened = () => {
    this._upgradeLanguages();
    return this._loadUserSnippets();
  };
  return this.onKeyDownListener = (event) => {
    var abbreviation, editor, expand, i, isSelection, key, koDoc, lang, len, len1, line, message, ref, regex, tempSnippet, toEpxand, toInsert, views;
    editor = require('ko/editor');
    views = require('ko/views');
    koDoc = views.current().get('koDoc');
    lang = koDoc.subLanguage;
    if (lang === false) {
      return true;
    }
    lang = lang.toLowerCase().replace(' ', '_');
    key = event.keyCode;
    if (key === 27 && inWrapMode) {
      notify.send('Xemmet: Wrap Selection has been canceled', {
        priority: 'info',
        category: 'xemmet'
      });
      inWrapMode = false;
      selection = '';
      return true;
    }
    if (key === 9) {
      if (event.shiftKey || koDoc.getTabstopInsertionTable({}).length > 0) {
        return true;
      }
      if (this.prefs.getBoolean('xemmet_strict_mode', true) && !this._isEnabledLang(lang)) {
        log.debug(`Prefs[global]: xemmet_strict_mode = true, Xemmet ignores ${lang}`);
        return true;
      }
      if (event.ctrlKey && !inWrapMode) {
        log.debug('Listener[global] ctrl+tab');
        if (this.prefs.getBoolean('xemmet_wrap_strict_mode', true) && this._getBaseLang(lang) !== 'html') {
          notify.send('Xemmet: Wrap Selection is in strict mode (HTML only)', {
            priority: 'info',
            category: 'xemmet'
          });
          e.preventDefault();
          return true;
        }
        selection = editor.getSelection();
        message = 'Selection';
        if (selection.length === 0 && this.prefs.getBoolean('xemmet_enable_line_wrap_selection', true)) {
          selection = editor.getLine();
          message = 'Current line';
          editor.goLineEnd();
          this._createSelection(selection.length, editor);
        } else if (selection.length === 0) {
          log.debug('Prefs[selection-grab]: xemmet_enable_line_wrap_selection = false, selection = null; return');
          return true;
        }
        event.preventDefault();
        inWrapMode = true;
        notify.send(`Xemmet: ${message} has been saved, write your abbreviation`, {
          priority: 'info',
          category: 'xemmet'
        });
        log.debug(`Listener[selection-grab] selection = ${selection}`);
        return editor.replaceSelection('');
      } else if (inWrapMode) {
        inWrapMode = false;
        if (this._wrapSelection(editor, lang)) {
          return event.preventDefault();
        }
      } else if (editor.getSelection().length === 0) {
        log.debug('Listener[global] tab');
        line = editor.getLine().substring(0, editor.getCursorPosition().ch);
        log.debug(`Listener[tab] string before caret '${line}'`);
        toEpxand = this._strip(line);
        if (typeof ignoreExpand[lang] !== 'undefined') {
          ref = ignoreExpand[lang];
          for (i = 0, len1 = ref.length; i < len1; i++) {
            regex = ref[i];
            if (regex.test(toEpxand)) {
              this._finalize();
            }
          }
        }
        isSelection = false;
        log.debug(`Listener[tab-expand] possible abbreviation before caret '${toEpxand}'`);
        abbreviation = this._isAbbr(toEpxand, lang);
        if (abbreviation.success) {
          log.debug('Listener[tab-expand; success] inserting abbreviation');
          editor.scimoz().beginUndoAction();
          event.preventDefault();
          toInsert = abbreviation.data;
          expand = this._prepare(this._expand(toInsert, lang));
          len = abbreviation.length;
          log.debug(`Listener[tab-expand; success] to insert: ${expand} (from abbr ${toInsert}); len = ${len}`);
          if (!isSelection) {
            this._createSelection(len, editor);
          }
          tempSnippet = this._createSnippet(expand, false);
          ko.abbrev.insertAbbrevSnippet(tempSnippet, require('ko/views').current().get());
          return editor.scimoz().endUndoAction();
        }
      } else {
        return this._finalize();
      }
    }
  };
}).apply(module.exports);
